/**
 * Logic cho game "T√¥i l√† ai"
 * X·ª≠ l√Ω c√°c thao t√°c li√™n quan ƒë·∫øn vi·ªác ƒëo√°n ƒë·ªëi t∆∞·ª£ng qua g·ª£i √Ω
 */

import { getRandomQuestion, getAllCategories } from '../data/guessWhoData';

/**
 * Chu·∫©n h√≥a chu·ªói ƒë·ªÉ so s√°nh (b·ªè d·∫•u, lowercase, trim)
 * @param {string} str - Chu·ªói c·∫ßn chu·∫©n h√≥a
 * @returns {string} Chu·ªói ƒë√£ chu·∫©n h√≥a
 */
export const normalizeString = (str) => {
  if (!str) return '';
  
  return str
    .toLowerCase()
    .trim()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // B·ªè d·∫•u ti·∫øng Vi·ªát
    .replace(/[ƒë]/g, 'd') // Thay ƒë th√†nh d
    .replace(/[^a-z0-9\s]/g, '') // Ch·ªâ gi·ªØ ch·ªØ, s·ªë v√† kho·∫£ng tr·∫Øng
    .replace(/\s+/g, ' '); // Normalize kho·∫£ng tr·∫Øng
};

/**
 * Ki·ªÉm tra ƒë·ªô t∆∞∆°ng t·ª± gi·ªØa 2 chu·ªói
 * @param {string} answer - ƒê√°p √°n ƒë√∫ng
 * @param {string} guess - C√¢u tr·∫£ l·ªùi c·ªßa ng∆∞·ªùi ch∆°i
 * @returns {number} ƒêi·ªÉm t∆∞∆°ng t·ª± t·ª´ 0-100
 */
export const calculateSimilarity = (answer, guess) => {
  const normalizedAnswer = normalizeString(answer);
  const normalizedGuess = normalizeString(guess);
  
  if (normalizedAnswer === normalizedGuess) return 100;
  
  // Ki·ªÉm tra ch·ª©a t·ª´ kh√≥a ch√≠nh
  const answerWords = normalizedAnswer.split(' ');
  const guessWords = normalizedGuess.split(' ');
  
  let matchingWords = 0;
  answerWords.forEach(word => {
    if (word.length > 2 && guessWords.some(gw => gw.includes(word) || word.includes(gw))) {
      matchingWords++;
    }
  });
  
  const wordSimilarity = (matchingWords / answerWords.length) * 100;
  
  // Ki·ªÉm tra Levenshtein distance cho to√†n b·ªô chu·ªói
  const levenshteinSimilarity = 100 - (levenshteinDistance(normalizedAnswer, normalizedGuess) / Math.max(normalizedAnswer.length, normalizedGuess.length)) * 100;
  
  return Math.max(wordSimilarity, levenshteinSimilarity);
};

/**
 * T√≠nh kho·∫£ng c√°ch Levenshtein gi·ªØa 2 chu·ªói
 * @param {string} str1 - Chu·ªói 1
 * @param {string} str2 - Chu·ªói 2
 * @returns {number} Kho·∫£ng c√°ch Levenshtein
 */
const levenshteinDistance = (str1, str2) => {
  const matrix = [];
  
  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }
  
  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  
  return matrix[str2.length][str1.length];
};

/**
 * Ki·ªÉm tra c√¢u tr·∫£ l·ªùi v√† tr·∫£ v·ªÅ k·∫øt qu·∫£
 * @param {string} answer - ƒê√°p √°n ƒë√∫ng
 * @param {string} guess - C√¢u tr·∫£ l·ªùi c·ªßa ng∆∞·ªùi ch∆°i
 * @param {number} hintCount - S·ªë g·ª£i √Ω ƒë√£ s·ª≠ d·ª•ng
 * @returns {Object} K·∫øt qu·∫£ ki·ªÉm tra
 */
export const checkGuess = (answer, guess, hintCount) => {
  if (!guess || guess.trim().length === 0) {
    return {
      isCorrect: false,
      similarity: 0,
      feedback: "H√£y nh·∫≠p c√¢u tr·∫£ l·ªùi c·ªßa b·∫°n!"
    };
  }
  
  if (guess.trim().length < 2) {
    return {
      isCorrect: false,
      similarity: 0,
      feedback: "C√¢u tr·∫£ l·ªùi qu√° ng·∫Øn!"
    };
  }
  
  const similarity = calculateSimilarity(answer, guess);
  
  if (similarity >= 95) {
    return {
      isCorrect: true,
      similarity: 100,
      feedback: "üéâ Ch√≠nh x√°c! B·∫°n ƒë√£ ƒëo√°n ƒë√∫ng!",
      score: calculateScore(hintCount, true)
    };
  } else if (similarity >= 70) {
    return {
      isCorrect: false,
      similarity: similarity,
      feedback: "üî• R·∫•t g·∫ßn r·ªìi! Th·ª≠ l·∫°i xem!",
      isClose: true
    };
  } else if (similarity >= 40) {
    return {
      isCorrect: false,
      similarity: similarity,
      feedback: "ü§î G·∫ßn ƒë√∫ng r·ªìi, nghƒ© th√™m ch√∫t n·ªØa!",
      isWarm: true
    };
  } else {
    return {
      isCorrect: false,
      similarity: similarity,
      feedback: "‚ùå Ch∆∞a ƒë√∫ng, th·ª≠ l·∫°i nh√©!",
      isCold: true
    };
  }
};

/**
 * T√≠nh ƒëi·ªÉm d·ª±a tr√™n s·ªë g·ª£i √Ω ƒë√£ s·ª≠ d·ª•ng
 * @param {number} hintsUsed - S·ªë g·ª£i √Ω ƒë√£ d√πng
 * @param {boolean} isCorrect - C√≥ ƒëo√°n ƒë√∫ng kh√¥ng
 * @returns {number} ƒêi·ªÉm s·ªë
 */
export const calculateScore = (hintsUsed, isCorrect) => {
  if (!isCorrect) return 0;
  
  const baseScore = 100;
  const hintPenalty = hintsUsed * 15; // Tr·ª´ 15 ƒëi·ªÉm m·ªói g·ª£i √Ω
  
  return Math.max(baseScore - hintPenalty, 10); // T·ªëi thi·ªÉu 10 ƒëi·ªÉm
};

/**
 * L·∫•y c√¢u ƒë·ªë m·ªõi cho game
 * @param {Array} usedQuestionIds - M·∫£ng ID c√°c c√¢u ƒë√£ ch∆°i
 * @returns {Object|null} C√¢u ƒë·ªë m·ªõi ho·∫∑c null n·∫øu h·∫øt c√¢u
 */
export const getNewGuessWhoQuestion = (usedQuestionIds = []) => {
  return getRandomQuestion(usedQuestionIds);
};

/**
 * Ki·ªÉm tra xem game ƒë√£ k·∫øt th√∫c ch∆∞a
 * @param {Array} usedQuestionIds - M·∫£ng ID c√°c c√¢u ƒë√£ ch∆°i
 * @param {number} maxQuestions - S·ªë c√¢u t·ªëi ƒëa
 * @returns {boolean} Game ƒë√£ k·∫øt th√∫c hay ch∆∞a
 */
export const isGameFinished = (usedQuestionIds, maxQuestions) => {
  return usedQuestionIds.length >= maxQuestions;
};

/**
 * T√≠nh t·ª∑ l·ªá ƒë√∫ng
 * @param {number} correctAnswers - S·ªë c√¢u ƒë√∫ng
 * @param {number} totalQuestions - T·ªïng s·ªë c√¢u
 * @returns {number} T·ª∑ l·ªá ph·∫ßn trƒÉm
 */
export const getAccuracyPercentage = (correctAnswers, totalQuestions) => {
  if (totalQuestions === 0) return 0;
  return Math.round((correctAnswers / totalQuestions) * 100);
};

/**
 * L·∫•y th√¥ng ƒëi·ªáp k·∫øt qu·∫£ d·ª±a tr√™n hi·ªáu su·∫•t
 * @param {number} accuracy - T·ª∑ l·ªá ƒë√∫ng (%)
 * @param {number} totalScore - T·ªïng ƒëi·ªÉm
 * @returns {string} Th√¥ng ƒëi·ªáp
 */
export const getPerformanceMessage = (accuracy, totalScore) => {
  if (accuracy >= 90) {
    return "üèÜ Xu·∫•t s·∫Øc! B·∫°n l√† th√°m t·ª≠ si√™u h·∫°ng!";
  } else if (accuracy >= 75) {
    return "üéØ Tuy·ªát v·ªùi! B·∫°n c√≥ t√†i suy lu·∫≠n!";
  } else if (accuracy >= 60) {
    return "üëç Kh√° t·ªët! B·∫°n ƒë√£ c·ªë g·∫Øng r·∫•t nhi·ªÅu!";
  } else if (accuracy >= 40) {
    return "ü§î Kh√¥ng t·ªá! C√≤n c·∫ßn luy·ªán t·∫≠p th√™m!";
  } else {
    return "üòÖ H√£y th·ª≠ l·∫°i! Practice makes perfect!";
  }
};

/**
 * L∆∞u th·ªëng k√™ game v√†o localStorage
 * @param {Object} gameStats - Th·ªëng k√™ game
 */
export const saveGameStats = (gameStats) => {
  try {
    const existingStats = getGameStats();
    const updatedStats = {
      totalGames: existingStats.totalGames + 1,
      totalQuestions: existingStats.totalQuestions + gameStats.questionsAnswered,
      totalCorrect: existingStats.totalCorrect + gameStats.correctAnswers,
      totalScore: existingStats.totalScore + gameStats.score,
      bestScore: Math.max(existingStats.bestScore, gameStats.score),
      lastPlayed: Date.now(),
      // Stats by category
      categoryStats: updateCategoryStats(existingStats.categoryStats, gameStats.categoryResults)
    };
    
    localStorage.setItem('guessWhoStats', JSON.stringify(updatedStats));
  } catch (error) {
    console.warn('Kh√¥ng th·ªÉ l∆∞u th·ªëng k√™:', error);
  }
};

/**
 * L·∫•y th·ªëng k√™ game t·ª´ localStorage
 * @returns {Object} Th·ªëng k√™ game
 */
export const getGameStats = () => {
  try {
    const stats = localStorage.getItem('guessWhoStats');
    if (stats) {
      return JSON.parse(stats);
    }
  } catch (error) {
    console.warn('Kh√¥ng th·ªÉ ƒë·ªçc th·ªëng k√™:', error);
  }
  
  // Default stats
  return {
    totalGames: 0,
    totalQuestions: 0,
    totalCorrect: 0,
    totalScore: 0,
    bestScore: 0,
    lastPlayed: null,
    categoryStats: {}
  };
};

/**
 * C·∫≠p nh·∫≠t th·ªëng k√™ theo category
 * @param {Object} existingCategoryStats - Th·ªëng k√™ c≈© theo category
 * @param {Object} newCategoryResults - K·∫øt qu·∫£ m·ªõi theo category
 * @returns {Object} Th·ªëng k√™ ƒë√£ c·∫≠p nh·∫≠t
 */
const updateCategoryStats = (existingCategoryStats, newCategoryResults) => {
  const updated = { ...existingCategoryStats };
  
  Object.keys(newCategoryResults).forEach(category => {
    if (!updated[category]) {
      updated[category] = { correct: 0, total: 0 };
    }
    updated[category].correct += newCategoryResults[category].correct;
    updated[category].total += newCategoryResults[category].total;
  });
  
  return updated;
};

/**
 * X√≥a th·ªëng k√™ game
 */
export const clearGameStats = () => {
  try {
    localStorage.removeItem('guessWhoStats');
  } catch (error) {
    console.warn('Kh√¥ng th·ªÉ x√≥a th·ªëng k√™:', error);
  }
};

/**
 * Format th·ªùi gian hi·ªÉn th·ªã
 * @param {number} timestamp - Timestamp
 * @returns {string} Th·ªùi gian ƒë√£ format
 */
export const formatLastPlayed = (timestamp) => {
  if (!timestamp) return 'Ch∆∞a t·ª´ng ch∆°i';
  
  const date = new Date(timestamp);
  const now = new Date();
  const diffInMinutes = Math.floor((now - date) / (1000 * 60));
  
  if (diffInMinutes < 1) {
    return "V·ª´a xong";
  } else if (diffInMinutes < 60) {
    return `${diffInMinutes} ph√∫t tr∆∞·ªõc`;
  } else if (diffInMinutes < 1440) {
    const diffInHours = Math.floor(diffInMinutes / 60);
    return `${diffInHours} gi·ªù tr∆∞·ªõc`;
  } else {
    return date.toLocaleDateString('vi-VN');
  }
};

/**
 * L·∫•y g·ª£i √Ω ti·∫øp theo
 * @param {Array} hints - M·∫£ng c√°c g·ª£i √Ω
 * @param {number} currentHintIndex - Index g·ª£i √Ω hi·ªán t·∫°i
 * @returns {string|null} G·ª£i √Ω ti·∫øp theo ho·∫∑c null
 */
export const getNextHint = (hints, currentHintIndex) => {
  if (currentHintIndex >= hints.length - 1) {
    return null; // H·∫øt g·ª£i √Ω
  }
  
  return hints[currentHintIndex + 1];
};

/**
 * L·∫•y danh s√°ch c√°c lo·∫°i category
 * @returns {Array} M·∫£ng categories
 */
export const getCategories = () => {
  return getAllCategories();
};

/**
 * T·∫°o g·ª£i √Ω cho ng∆∞·ªùi ch∆°i d·ª±a tr√™n c√¢u tr·∫£ l·ªùi g·∫ßn ƒë√∫ng
 * @param {string} answer - ƒê√°p √°n ƒë√∫ng
 * @param {string} guess - C√¢u tr·∫£ l·ªùi c·ªßa ng∆∞·ªùi ch∆°i
 * @returns {string} G·ª£i √Ω
 */
export const generateHintFromGuess = (answer, guess) => {
  const normalizedAnswer = normalizeString(answer);
  const normalizedGuess = normalizeString(guess);
  
  const answerWords = normalizedAnswer.split(' ');
  const guessWords = normalizedGuess.split(' ');
  
  // Ki·ªÉm tra ƒë·ªô d√†i
  if (answer.length > guess.length + 3) {
    return "üí° Th·ª≠ nghƒ© t√™n d√†i h∆°n m·ªôt ch√∫t!";
  } else if (answer.length < guess.length - 3) {
    return "üí° Th·ª≠ nghƒ© t√™n ng·∫Øn h∆°n m·ªôt ch√∫t!";
  }
  
  // Ki·ªÉm tra s·ªë t·ª´
  if (answerWords.length > guessWords.length) {
    return "üí° ƒê√°p √°n c√≥ nhi·ªÅu t·ª´ h∆°n!";
  } else if (answerWords.length < guessWords.length) {
    return "üí° ƒê√°p √°n c√≥ √≠t t·ª´ h∆°n!";
  }
  
  // Ki·ªÉm tra ch·ªØ c√°i ƒë·∫ßu
  if (normalizedAnswer[0] === normalizedGuess[0]) {
    return "üí° Ch·ªØ c√°i ƒë·∫ßu ƒë√∫ng r·ªìi! Ti·∫øp t·ª•c!";
  }
  
  return "üí° Th·ª≠ suy nghƒ© theo h∆∞·ªõng kh√°c!";
}; 