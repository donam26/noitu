/**
 * Logic cho game "T√¥i l√† ai"
 * X·ª≠ l√Ω c√°c thao t√°c li√™n quan ƒë·∫øn vi·ªác ƒëo√°n ƒë·ªëi t∆∞·ª£ng qua g·ª£i √Ω
 */

// KH√îNG import t·ª´ file data n·ªØa
// import { getRandomQuestion, getAllCategories } from '../data/guessWhoData';

/**
 * Chu·∫©n h√≥a chu·ªói ƒë·ªÉ so s√°nh (b·ªè d·∫•u, lowercase, trim)
 * @param {string} str - Chu·ªói c·∫ßn chu·∫©n h√≥a
 * @returns {string} Chu·ªói ƒë√£ chu·∫©n h√≥a
 */
export const normalizeString = (str) => {
  if (!str) return '';
  
  return str
    .toLowerCase()
    .trim()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // B·ªè d·∫•u ti·∫øng Vi·ªát
    .replace(/[ƒë]/g, 'd') // Thay ƒë th√†nh d
    .replace(/[^a-z0-9\s]/g, '') // Ch·ªâ gi·ªØ ch·ªØ, s·ªë v√† kho·∫£ng tr·∫Øng
    .replace(/\s+/g, ' '); // Normalize kho·∫£ng tr·∫Øng
};

/**
 * Ki·ªÉm tra ƒë·ªô t∆∞∆°ng t·ª± gi·ªØa 2 chu·ªói
 * @param {string} answer - ƒê√°p √°n ƒë√∫ng
 * @param {string} guess - C√¢u tr·∫£ l·ªùi c·ªßa ng∆∞·ªùi ch∆°i
 * @returns {number} ƒêi·ªÉm t∆∞∆°ng t·ª± t·ª´ 0-100
 */
export const calculateSimilarity = (answer, guess) => {
  const normalizedAnswer = normalizeString(answer);
  const normalizedGuess = normalizeString(guess);
  
  if (normalizedAnswer === normalizedGuess) return 100;
  
  // Ki·ªÉm tra ch·ª©a t·ª´ kh√≥a ch√≠nh
  const answerWords = normalizedAnswer.split(' ');
  const guessWords = normalizedGuess.split(' ');
  
  let matchingWords = 0;
  answerWords.forEach(word => {
    if (word.length > 2 && guessWords.some(gw => gw.includes(word) || word.includes(gw))) {
      matchingWords++;
    }
  });
  
  const wordSimilarity = (matchingWords / answerWords.length) * 100;
  
  // Ki·ªÉm tra Levenshtein distance cho to√†n b·ªô chu·ªói
  const levenshteinSimilarity = 100 - (levenshteinDistance(normalizedAnswer, normalizedGuess) / Math.max(normalizedAnswer.length, normalizedGuess.length)) * 100;
  
  return Math.max(wordSimilarity, levenshteinSimilarity);
};

/**
 * T√≠nh kho·∫£ng c√°ch Levenshtein gi·ªØa 2 chu·ªói
 * @param {string} str1 - Chu·ªói 1
 * @param {string} str2 - Chu·ªói 2
 * @returns {number} Kho·∫£ng c√°ch Levenshtein
 */
const levenshteinDistance = (str1, str2) => {
  const matrix = [];
  
  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }
  
  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  
  return matrix[str2.length][str1.length];
};

/**
 * Ki·ªÉm tra c√¢u tr·∫£ l·ªùi v√† tr·∫£ v·ªÅ k·∫øt qu·∫£
 * @param {string} answer - ƒê√°p √°n ƒë√∫ng
 * @param {string} guess - C√¢u tr·∫£ l·ªùi c·ªßa ng∆∞·ªùi ch∆°i
 * @param {number} hintCount - S·ªë g·ª£i √Ω ƒë√£ s·ª≠ d·ª•ng
 * @returns {Object} K·∫øt qu·∫£ ki·ªÉm tra
 */
export const checkGuess = (answer, guess, hintCount) => {
  if (!guess || guess.trim().length === 0) {
    return {
      isCorrect: false,
      similarity: 0,
      feedback: "H√£y nh·∫≠p c√¢u tr·∫£ l·ªùi c·ªßa b·∫°n!"
    };
  }
  
  if (guess.trim().length < 2) {
    return {
      isCorrect: false,
      similarity: 0,
      feedback: "C√¢u tr·∫£ l·ªùi qu√° ng·∫Øn!"
    };
  }
  
  const similarity = calculateSimilarity(answer, guess);
  
  if (similarity >= 95) {
    return {
      isCorrect: true,
      similarity: 100,
      feedback: "üéâ Ch√≠nh x√°c! B·∫°n ƒë√£ ƒëo√°n ƒë√∫ng!",
      score: calculateScore(hintCount, true)
    };
  } else if (similarity >= 70) {
    return {
      isCorrect: false,
      similarity: similarity,
      feedback: "üî• R·∫•t g·∫ßn r·ªìi! Th·ª≠ l·∫°i xem!",
      isClose: true
    };
  } else if (similarity >= 40) {
    return {
      isCorrect: false,
      similarity: similarity,
      feedback: "ü§î G·∫ßn ƒë√∫ng r·ªìi, nghƒ© th√™m ch√∫t n·ªØa!",
      isWarm: true
    };
  } else {
    return {
      isCorrect: false,
      similarity: similarity,
      feedback: "‚ùå Ch∆∞a ƒë√∫ng, th·ª≠ l·∫°i nh√©!",
      isCold: true
    };
  }
};

/**
 * T√≠nh ƒëi·ªÉm d·ª±a tr√™n s·ªë g·ª£i √Ω ƒë√£ s·ª≠ d·ª•ng
 * @param {number} hintsUsed - S·ªë g·ª£i √Ω ƒë√£ d√πng
 * @param {boolean} isCorrect - C√≥ ƒëo√°n ƒë√∫ng kh√¥ng
 * @returns {number} ƒêi·ªÉm s·ªë
 */
export const calculateScore = (hintsUsed, isCorrect) => {
  if (!isCorrect) return 0;
  
  const baseScore = 100;
  const hintPenalty = hintsUsed * 15; // Tr·ª´ 15 ƒëi·ªÉm m·ªói g·ª£i √Ω
  
  return Math.max(baseScore - hintPenalty, 10); // T·ªëi thi·ªÉu 10 ƒëi·ªÉm
};

/**
 * Ki·ªÉm tra xem game ƒë√£ k·∫øt th√∫c ch∆∞a
 * @param {Array} usedQuestionIds - M·∫£ng ID c√°c c√¢u ƒë√£ ch∆°i
 * @param {number} maxQuestions - S·ªë c√¢u t·ªëi ƒëa
 * @param {number} totalQuestions - T·ªïng s·ªë c√¢u c√≥ s·∫µn
 * @returns {boolean} Game ƒë√£ k·∫øt th√∫c hay ch∆∞a
 */
export const isGameFinished = (usedQuestionIds, maxQuestions, totalQuestions = Infinity) => {
  return usedQuestionIds.length >= maxQuestions || usedQuestionIds.length >= totalQuestions;
};

/**
 * T√≠nh t·ª∑ l·ªá ƒë√∫ng
 * @param {number} correctAnswers - S·ªë c√¢u ƒë√∫ng
 * @param {number} totalQuestions - T·ªïng s·ªë c√¢u
 * @returns {number} T·ª∑ l·ªá ph·∫ßn trƒÉm
 */
export const getAccuracyPercentage = (correctAnswers, totalQuestions) => {
  if (totalQuestions === 0) return 0;
  return Math.round((correctAnswers / totalQuestions) * 100);
};

/**
 * L·∫•y th√¥ng ƒëi·ªáp k·∫øt qu·∫£ d·ª±a tr√™n hi·ªáu su·∫•t
 * @param {number} accuracy - T·ª∑ l·ªá ƒë√∫ng (%)
 * @param {number} totalScore - T·ªïng ƒëi·ªÉm
 * @returns {string} Th√¥ng ƒëi·ªáp
 */
export const getPerformanceMessage = (accuracy, totalScore) => {
  if (accuracy >= 90) {
    return "üèÜ Xu·∫•t s·∫Øc! B·∫°n l√† th√°m t·ª≠ si√™u h·∫°ng!";
  } else if (accuracy >= 75) {
    return "üéØ Tuy·ªát v·ªùi! B·∫°n c√≥ t√†i suy lu·∫≠n!";
  } else if (accuracy >= 60) {
    return "üëç Kh√° t·ªët! B·∫°n ƒë√£ c·ªë g·∫Øng r·∫•t nhi·ªÅu!";
  } else if (accuracy >= 40) {
    return "ü§î Kh√¥ng t·ªá! C√≤n c·∫ßn luy·ªán t·∫≠p th√™m!";
  } else {
    return "üòÖ H√£y th·ª≠ l·∫°i! Practice makes perfect!";
  }
};

/**
 * L∆∞u th·ªëng k√™ game v√†o localStorage
 * @param {Object} gameStats - Th·ªëng k√™ game
 */
export const saveGameStats = (gameStats) => {
  try {
    const existingStats = getGameStats();
    const updatedStats = {
      totalGames: existingStats.totalGames + 1,
      totalQuestions: existingStats.totalQuestions + gameStats.questionsAnswered,
      totalCorrect: existingStats.totalCorrect + gameStats.correctAnswers,
      totalScore: existingStats.totalScore + gameStats.score,
      bestScore: Math.max(existingStats.bestScore, gameStats.score),
      lastPlayed: Date.now(),
      // Stats by category
      categoryStats: updateCategoryStats(existingStats.categoryStats, gameStats.categoryResults)
    };
    
    localStorage.setItem('guessWhoStats', JSON.stringify(updatedStats));
  } catch (error) {
    console.warn('Kh√¥ng th·ªÉ l∆∞u th·ªëng k√™:', error);
  }
};

/**
 * L·∫•y th·ªëng k√™ game t·ª´ localStorage
 * @returns {Object} Th·ªëng k√™ game
 */
export const getGameStats = () => {
  try {
    const stats = localStorage.getItem('guessWhoStats');
    if (stats) {
      return JSON.parse(stats);
    }
  } catch (error) {
    console.warn('Kh√¥ng th·ªÉ ƒë·ªçc th·ªëng k√™:', error);
  }
  
  // Default stats
  return {
    totalGames: 0,
    totalQuestions: 0,
    totalCorrect: 0,
    totalScore: 0,
    bestScore: 0,
    lastPlayed: null,
    categoryStats: {}
  };
};

/**
 * C·∫≠p nh·∫≠t th·ªëng k√™ theo danh m·ª•c
 * @param {Object} existingCategoryStats - Th·ªëng k√™ danh m·ª•c hi·ªán t·∫°i
 * @param {Object} newCategoryResults - K·∫øt qu·∫£ m·ªõi theo danh m·ª•c
 * @returns {Object} Th·ªëng k√™ danh m·ª•c ƒë√£ c·∫≠p nh·∫≠t
 */
const updateCategoryStats = (existingCategoryStats, newCategoryResults) => {
  const updatedStats = { ...existingCategoryStats };
  
  Object.keys(newCategoryResults).forEach(category => {
    const newResult = newCategoryResults[category];
    if (!updatedStats[category]) {
      updatedStats[category] = { correct: 0, total: 0 };
    }
    updatedStats[category].correct += newResult.correct || 0;
    updatedStats[category].total += newResult.total || 0;
  });
  
  return updatedStats;
};

/**
 * X√≥a th·ªëng k√™ game
 */
export const clearGameStats = () => {
  try {
    localStorage.removeItem('guessWhoStats');
  } catch (error) {
    console.warn('Kh√¥ng th·ªÉ x√≥a th·ªëng k√™:', error);
  }
};

/**
 * Format th·ªùi gian ƒë√£ ch∆°i l·∫ßn cu·ªëi
 * @param {number} timestamp - Timestamp
 * @returns {string} Th·ªùi gian ƒë√£ format
 */
export const formatLastPlayed = (timestamp) => {
  if (!timestamp) return 'Ch∆∞a c√≥ d·ªØ li·ªáu';
  
  const date = new Date(timestamp);
  const now = new Date();
  const diffMs = now - date;
  const diffSec = Math.floor(diffMs / 1000);
  const diffMin = Math.floor(diffSec / 60);
  const diffHour = Math.floor(diffMin / 60);
  const diffDay = Math.floor(diffHour / 24);
  
  if (diffDay > 0) {
    return `${diffDay} ng√†y tr∆∞·ªõc`;
  } else if (diffHour > 0) {
    return `${diffHour} gi·ªù tr∆∞·ªõc`;
  } else if (diffMin > 0) {
    return `${diffMin} ph√∫t tr∆∞·ªõc`;
  } else {
    return 'V·ª´a xong';
  }
};

/**
 * L·∫•y g·ª£i √Ω ti·∫øp theo
 * @param {Array} hints - M·∫£ng c√°c g·ª£i √Ω
 * @param {number} currentHintIndex - Index g·ª£i √Ω hi·ªán t·∫°i
 * @returns {Object} G·ª£i √Ω ti·∫øp theo v√† index
 */
export const getNextHint = (hints, currentHintIndex) => {
  if (!hints || hints.length === 0) {
    return { hint: 'Kh√¥ng c√≥ g·ª£i √Ω n√†o kh·∫£ d·ª•ng', index: -1 };
  }
  
  const nextIndex = currentHintIndex + 1;
  if (nextIndex >= hints.length) {
    return { hint: 'ƒê√£ h·∫øt g·ª£i √Ω', index: currentHintIndex };
  }
  
  return {
    hint: hints[nextIndex],
    index: nextIndex
  };
};

/**
 * T·∫°o g·ª£i √Ω t·ª´ c√¢u tr·∫£ l·ªùi c·ªßa ng∆∞·ªùi ch∆°i
 * @param {string} answer - ƒê√°p √°n ƒë√∫ng
 * @param {string} guess - C√¢u tr·∫£ l·ªùi c·ªßa ng∆∞·ªùi ch∆°i
 * @returns {string} G·ª£i √Ω ƒë∆∞·ª£c t·∫°o
 */
export const generateHintFromGuess = (answer, guess) => {
  const normalizedAnswer = normalizeString(answer);
  const normalizedGuess = normalizeString(guess);
  
  if (normalizedGuess.length < 3) {
    return "H√£y nh·∫≠p nhi·ªÅu h∆°n ƒë·ªÉ c√≥ g·ª£i √Ω t·ªët h∆°n";
  }
  
  const answerWords = normalizedAnswer.split(' ');
  const guessWords = normalizedGuess.split(' ');
  
  // T√¨m t·ª´ t∆∞∆°ng ƒë·ªìng
  let matchedWords = [];
  answerWords.forEach(word => {
    if (word.length > 2 && guessWords.some(gw => gw.includes(word) || word.includes(gw))) {
      matchedWords.push(word);
    }
  });
  
  if (matchedWords.length > 0) {
    return `B·∫°n ƒë√£ ƒë√∫ng m·ªôt ph·∫ßn: "${matchedWords.join(', ')}" xu·∫•t hi·ªán trong ƒë√°p √°n.`;
  }
  
  // Ki·ªÉm tra c√≥ t·ª´ n√†o b·∫Øt ƒë·∫ßu gi·ªëng nhau kh√¥ng
  const firstAnswerWord = answerWords[0];
  const firstGuessWord = guessWords[0];
  
  if (firstAnswerWord && firstGuessWord && firstAnswerWord.charAt(0) === firstGuessWord.charAt(0)) {
    return `ƒê√°p √°n b·∫Øt ƒë·∫ßu b·∫±ng ch·ªØ c√°i "${firstAnswerWord.charAt(0).toUpperCase()}"`;
  }
  
  // G·ª£i √Ω s·ªë t·ª´
  if (Math.abs(answerWords.length - guessWords.length) > 1) {
    return `ƒê√°p √°n c√≥ ${answerWords.length} t·ª´.`;
  }
  
  return "H√£y th·ª≠ m·ªôt h∆∞·ªõng kh√°c. ƒê√°p √°n kh√¥ng li√™n quan ƒë·∫øn ƒëi·ªÅu b·∫°n ƒëo√°n.";
}; 